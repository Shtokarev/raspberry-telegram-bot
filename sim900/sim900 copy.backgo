package sim900

import (
	"bytes"
	"errors"
	"fmt"
	"log"
	"os"
	"regexp"
	"strings"
	"time"

	"github.com/tarm/serial"
)

const EOL_DEFAULT byte = '\n'

type SIM900 struct {
	port          *serial.Port
	config        *serial.Config
	logger        *log.Logger
	APN           string
	rxChar        chan byte
	closeReqChann chan bool
	closeAckChann chan error
	buff          *bytes.Buffer
	eol           uint8
}

func New(name string, baud int) *SIM900 {
	return &SIM900{
		config: &serial.Config{
			Name:        name,
			Baud:        baud,
			ReadTimeout: 0,
			Size:        8,
		},
		logger: log.New(os.Stdout, "[SIM900] ", log.LstdFlags),
		buff:   bytes.NewBuffer(make([]uint8, 256)),
		eol:    EOL_DEFAULT,
	}
}

func (sim *SIM900) Connect() error {
	// Open device serial port
	sim.logger.Println(sim.config)
	var err error
	sim.port, err = serial.OpenPort(sim.config)

	if err != nil {
		sim.logger.Fatal(err)
		return err
	}

	sim.port.Flush()

	sim.buff.Reset()
	// Open channels
	sim.rxChar = make(chan byte)
	// Enable threads
	go sim.readSerialPort()
	go sim.processSerialPort()

	time.Sleep((time.Second))

	n, err := sim.port.Write([]byte("AT\r"))
	if err != nil {
		log.Fatal(err)
	}

	fmt.Println("Sent bytes:", n)

	buf := make([]byte, 256)

	n, err = sim.port.Read(buf)

	if err != nil {
		fmt.Println("ERROR READING:")
		log.Fatal(err)
	}

	s := string(buf[:n])
	fmt.Println("Readen bytes:", n)
	fmt.Println("String(s):", s)

	fmt.Println("------------------ START AT:")
	// Ping to Modem
	return sim.At()
}

func (sim *SIM900) Disconnect() error {
	return sim.port.Close()
}

func (sim *SIM900) wait4response(cmd string, expected string, timeout time.Duration) (string, error) {
	// Send command
	n, err := sim.port.Write([]byte(cmd + CMD_CR))
	fmt.Println("Written", n)

	if err != nil {
		return "", err
	}

	// Wait for command response
	regexp := expected + "|" + CMD_ERROR
	response, err := sim.waitForRegexTimeout(regexp, timeout)
	if err != nil {
		return "", err
	}
	// Check if response is an error
	if strings.Contains(response, "ERROR") {
		return response, errors.New("Errors found on command response")
	}
	// Response received succesfully
	return response, nil
}

func (s *SIM900) At() error {
	_, err := s.wait4response(CMD_AT, CMD_OK, time.Second*2)
	return err
}

func (sim *SIM900) waitForRegexTimeout(exp string, timeout time.Duration) (string, error) {
	//Decode received data
	timeExpired := false

	regExpPatttern := regexp.MustCompile(exp)
	fmt.Println("regExpPatttern", regExpPatttern)

	//Timeout structure
	channel := make(chan string, 1)

	go func() {
		sim.logger.Printf("INF >> Waiting for RegExp: \"%s\"", exp)

		buffer := make([]byte, 256)

		for !timeExpired {
			// line, err := sim.port.ReadLine()
			n, err := sim.port.Read(buffer)
			line := string(buffer[:n])
			fmt.Println("line", line)

			if err != nil {
				// Do nothing
				sim.logger.Printf("INF >> ERROR: \"%s\"", err)
			} else {
				// result := []string{}
				result := regExpPatttern.FindAllString(line, -1)
				fmt.Println("result", result)
				if len(result) > 0 {
					channel <- result[0]
					break
				}
			}
		}
	}()

	select {
	case data := <-channel:
		sim.logger.Printf("INF >> The RegExp: \"%s\"", exp)
		sim.logger.Printf("INF >> Has been matched: \"%s\"", data)
		return data, nil
	case <-time.After(timeout):
		timeExpired = true
		sim.logger.Printf("INF >> Unable to match RegExp: \"%s\"", exp)
		return "", fmt.Errorf("Timeout expired")
	}
}

// func (sim *SIM900) readLine() (string, error) {
// 	sim.port.Read()
// 	line, err := sp.buff.ReadString(sp.eol)
// 	if err != nil {
// 		return "", err
// 	} else {
// 		return removeEOL(line), nil
// 	}

// }
func (sim *SIM900) readSerialPort() {
	rxBuff := make([]byte, 256)
	for {
		n, _ := sim.port.Read(rxBuff)
		// Write data to serial buffer
		sim.buff.Write(rxBuff[:n])
		for _, b := range rxBuff[:n] {
			sim.rxChar <- b
		}
	}
}

func (sim *SIM900) processSerialPort() {
	screenBuff := make([]byte, 0)
	var lastRxByte byte
	for {
		lastRxByte = <-sim.rxChar
		// Print received lines
		switch lastRxByte {
		case sim.eol:

			// EOL - Print received data
			if len(screenBuff) > 0 {
				sim.logger.Printf("Rx << %s", string(append(screenBuff, lastRxByte)))
			}
			screenBuff = make([]byte, 0) //Clean buffer
			break
		default:
			screenBuff = append(screenBuff, lastRxByte)
		}
	}
}
